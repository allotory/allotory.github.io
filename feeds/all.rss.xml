<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Amazilia</title><link href="http://allotory.github.io/" rel="alternate"></link><link href="http://allotory.github.io/feeds/all.rss.xml" rel="self"></link><id>http://allotory.github.io/</id><updated>2016-02-29T00:00:00+08:00</updated><entry><title>Git基础笔记</title><link href="http://allotory.github.io/posts/2016/02/29/pro_git/" rel="alternate"></link><updated>2016-02-29T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2016-02-29:posts/2016/02/29/pro_git/</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中化的版本控制系统（Centralized Version Control Systems，简称CVCS ），诸如 CVS，Subversion 以及 Perforce 等，最显而易见的缺点是中央服务器的单点故障。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式版本控制系统（ Distributed Version Control System，简称DVCS ），诸如 Git，Mercurial，Bazaar 还有 Darcs 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。&lt;/p&gt;
&lt;p&gt;已提交表示该文件已经被安全地保存在本地数据库中了；—— git commit&lt;/p&gt;
&lt;p&gt;已修改表示修改了某个文件，但还没有提交保存；&lt;/p&gt;
&lt;p&gt;已暂存表示把已修改的文件放在下次提交时要保存的清单中。—— git add&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 管理项目时，文件流转的三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个项目都有一个 git 目录，它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本的 Git 工作流程&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/11_local_operations.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在工作目录中修改某些文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对这些修改了的文件作快照，并保存到暂存区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交更新，将保存在暂存区域的文件快照转储到git 目录中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git config（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用--global 选项，读写的就是这个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置个人的用户名称和电子邮件地址：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;Ellery Zhang&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git config --global user.email al**ry@msn.com
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认使用的文本编辑器，Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config --global core.editor emacs
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查已有的配置信息，可以使用 git config --list 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config --list
core.symlinks&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;
core.autocrlf&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
color.diff&lt;span class="o"&gt;=&lt;/span&gt;auto
color.status&lt;span class="o"&gt;=&lt;/span&gt;auto
color.branch&lt;span class="o"&gt;=&lt;/span&gt;auto
color.interactive&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
pack.packsizelimit&lt;span class="o"&gt;=&lt;/span&gt;2g
help.format&lt;span class="o"&gt;=&lt;/span&gt;html
http.sslcainfo&lt;span class="o"&gt;=&lt;/span&gt;/bin/curl-ca-bundle.crt
sendemail.smtpserver&lt;span class="o"&gt;=&lt;/span&gt;/bin/msmtp.exe
diff.astextplain.textconv&lt;span class="o"&gt;=&lt;/span&gt;astextplain
rebase.autosquash&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
gui.encoding&lt;span class="o"&gt;=&lt;/span&gt;utf-8
i18n.commitencoding&lt;span class="o"&gt;=&lt;/span&gt;GB2312
svn.pathnameencoding&lt;span class="o"&gt;=&lt;/span&gt;GB2312
user.name&lt;span class="o"&gt;=&lt;/span&gt;Ellery  Zhang
user.email&lt;span class="o"&gt;=&lt;/span&gt;al***ry@msn.com
core.autocrlf&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;
core.excludesfile&lt;span class="o"&gt;=&lt;/span&gt;D:&lt;span class="se"&gt;\D&lt;/span&gt;ocuments&lt;span class="se"&gt;\g&lt;/span&gt;itignore_global.txt
i18n.commitencoding&lt;span class="o"&gt;=&lt;/span&gt;utf-8
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config user.name
Ellery  Zhang
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，有三种方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git &lt;span class="nb"&gt;help&lt;/span&gt; &amp;lt;verb&amp;gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git &amp;lt;verb&amp;gt; --help
&lt;span class="nv"&gt;$ &lt;/span&gt;man git-&amp;lt;verb&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如：学习 config 用法，会在浏览器中打开帮助页面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git &lt;span class="nb"&gt;help &lt;/span&gt;config
Launching default browser to display HTML ...
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git init
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。克隆仓库的命令格式为 git clone [url] 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone git@github.com:allotory/mellisuga.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令最后指定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone git@github.com:allotory/mellisuga.git newname
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s):// 或者 user@server:/path.git 表示的 SSH 传输协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。&lt;/p&gt;
&lt;p&gt;已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新（未修改），已修改或者已放入暂存区。&lt;/p&gt;
&lt;p&gt;所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/11_life_cycle.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要确定哪些文件当前处于什么状态，可以用 git status 命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git status
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;新建一个 readme文件，再次查看状态&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Initial commit
Untracked files:
  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to include in what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
        readme.txt
nothing added to commit but untracked files present &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add&amp;quot;&lt;/span&gt; to track&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add readme.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再次查看状态  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Initial commit
Changes to be committed:
  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;
        new file:   readme.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提交更新时请一定要确认还有什么修改过的或新建的文件还没有git add 过，否则提交的时候不会记录这些还没暂存起来的变化。&lt;/p&gt;
&lt;p&gt;所以，每次提交前，先用git status 看下，是不是都已暂存，然后再运行提交命令git commit：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s1"&gt;&amp;#39;add readme&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;master &lt;span class="o"&gt;(&lt;/span&gt;root-commit&lt;span class="o"&gt;)&lt;/span&gt; a40e540&lt;span class="o"&gt;]&lt;/span&gt; add readme
 &lt;span class="m"&gt;1&lt;/span&gt; file changed, &lt;span class="m"&gt;1&lt;/span&gt; insertion&lt;span class="o"&gt;(&lt;/span&gt;+&lt;span class="o"&gt;)&lt;/span&gt;
 create mode &lt;span class="m"&gt;100644&lt;/span&gt; readme.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-m 参数后跟提交说明。如果不使用 -m 参数，则会启动文本编辑器以便输入本次提交的说明。&lt;/p&gt;
&lt;p&gt;可以看到，提交后它会告诉你，当前是在（master）分支提交的，本次提交的完整 SHA-1 校验和是（a40e540），以及在本次提交中，有（1）个文件修订过，（1）行添改和删改过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暂存已修改文件，修改readme文件后查看状态&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class="k"&gt;for&lt;/span&gt; commit:
  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to update what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to discard changes in working directory&lt;span class="o"&gt;)&lt;/span&gt;
        modified:   readme.txt
no changes added to commit &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git add&amp;quot;&lt;/span&gt; and/or &lt;span class="s2"&gt;&amp;quot;git commit -a&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件 readme.txt 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 &lt;/p&gt;
&lt;p&gt;要暂存这次更新，需要运行 git add 命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add readme.txt
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;&amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot;&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;
        modified:   readme.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时文件已暂存，下次提交时就会一并记录到仓库。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git status 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status --short 命令，你将得到更为紧凑的格式输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件 .gitignore 的格式规范如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有空行或者以 ＃ 开头的行都会被 Git 忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用标准的 glob 模式匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配模式可以以（ / ）开头防止递归。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配模式可以以（ / ）结尾指定目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（ ! ）取反。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要查看尚未暂存的文件更新了哪些部分，不加参数直接输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git diff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。&lt;/p&gt;
&lt;p&gt;git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若要查看已暂存的将要添加到下次提交的内容，可以用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; diff --cached&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或（推荐使用）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; diff --staged&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; rm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; rm -f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留该文件在当前操作目录中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; rm  --cached&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 中对文件重命名&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git mv file_from file_to
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实，运行 git mv 就相当于运行了下面三条命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mv README.md README
&lt;span class="nv"&gt;$ &lt;/span&gt;git rm README.md
&lt;span class="nv"&gt;$ &lt;/span&gt;git add README
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看提交历史&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认时此命令会按提交时间倒序列出所有的更新，会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;commit a40e54088aa857b2b46c0c9fe0a0f2455bea51a5
Author: Ellery &amp;lt;allotory@msn.com&amp;gt;
Date:   Mon Jan 4 16:40:47 2016 +0800
    add readme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;git log 有很多参数，参数是 -p ，用来显示每次提交的内容差异。 -2 来表示仅显示最近两次提交&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log -p -2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;想看到每次提交的简略的统计信息，你可以使用 --stat 参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --stat
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;--stat 参数在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。&lt;/p&gt;
&lt;p&gt;--shortstat 只显示 --stat 中最后的参数修改添加移除统计。&lt;/p&gt;
&lt;p&gt;另一个常用的参数是 --pretty 。 这个参数可以指定使用不同于默认格式的方式展示提交历史。&lt;/p&gt;
&lt;p&gt;比如 oneline 将每个提交放在一行显示，查看的提交数很大时很有用，此时仅会显示sha-1和提交说明。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;oneline
b413d95e070aa3dc4ad425644a4086f00c983ba7 add &lt;span class="nb"&gt;test&lt;/span&gt;
559eb5339da498e847eadb3d579bc267d0684627 insert readme
a40e54088aa857b2b46c0c9fe0a0f2455bea51a5 add readme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外还有 short 格式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;short
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author: Ellery &amp;lt;allotory@msn.com&amp;gt;
    add &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;full格式 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;full
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author: Ellery &amp;lt;allotory@msn.com&amp;gt;
Commit: Ellery &amp;lt;allotory@msn.com&amp;gt;
    add &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;fuller格式 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;fuller
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author:     Ellery &amp;lt;allotory@msn.com&amp;gt;
AuthorDate: Mon Jan &lt;span class="m"&gt;4&lt;/span&gt; 16:55:11 &lt;span class="m"&gt;2016&lt;/span&gt; +0800
Commit:     Ellery &amp;lt;allotory@msn.com&amp;gt;
CommitDate: Mon Jan &lt;span class="m"&gt;4&lt;/span&gt; 16:55:11 &lt;span class="m"&gt;2016&lt;/span&gt; +0800
    add &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;format参数可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;format:&lt;span class="s2"&gt;&amp;quot;%h - %an, %ar : %s&amp;quot;&lt;/span&gt;
b413d95 - Ellery, &lt;span class="m"&gt;6&lt;/span&gt; days ago : add &lt;span class="nb"&gt;test&lt;/span&gt;
559eb53 - Ellery, &lt;span class="m"&gt;6&lt;/span&gt; days ago : insert readme
a40e540 - Ellery, &lt;span class="m"&gt;6&lt;/span&gt; days ago : add readme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些     ASCII字符串来形象地展示你的分支、合并历史&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git log --pretty&lt;span class="o"&gt;=&lt;/span&gt;format:&lt;span class="s2"&gt;&amp;quot;%h %s&amp;quot;&lt;/span&gt; --graph
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;撤消操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git commit --amend
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，所修改的只是提交信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取消已暂存文件，将以暂存的文件从暂存区移除&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reset HEAD test.md
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;撤消对文件的修改&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout -- test.md
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程仓库是指托管在因特网或其他网络中的项目的版本库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看已经配置的远程仓库服务器，可以使用 git remote 命令，如果你已经克隆了远程的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote
origin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定选项 -v ，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote -v
origin  git@github.com:allotory/mellisuga.git &lt;span class="o"&gt;(&lt;/span&gt;fetch&lt;span class="o"&gt;)&lt;/span&gt;
origin  git@github.com:allotory/mellisuga.git &lt;span class="o"&gt;(&lt;/span&gt;push&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加远程仓库，运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; remote add me git@github.com:allotory/mellisuga.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在命令行中使用字符串 me 来代替整个 URL。&lt;/p&gt;
&lt;p&gt;如果你想拉取远程仓库中有但你没有的信息，可以运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt; &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; fetch me&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt; &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; fetch git@github.com:allotory/mellisuga.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从远程仓库中抓取与拉取&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fetch &lt;span class="o"&gt;[&lt;/span&gt;remote-name&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fetch origin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 clone 命令克隆了某个仓库，命令会自动将其添加为远程仓库并默认以 'origin' 为简写。所以上述命令将会拥有那个远程仓库中所有分支的引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fetch origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;抓取回origin主机的master分支到本地。&lt;/p&gt;
&lt;p&gt;git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有一个分支设置为跟踪一个远程分支， git pull 命令来自动的抓取然后合并远程分支到当前分支。&lt;/p&gt;
&lt;p&gt;默认情况下， git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推送到远程仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git push [remotename] [branch-name]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要将 master 分支推送到 origin 服务器时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看某个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。会列出远程仓库的 URL 与跟踪分支的信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote show origin
* remote origin
  Fetch URL: git@github.com:allotory/mellisuga.git
  Push  URL: git@github.com:allotory/mellisuga.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;git pull&amp;#39;&lt;/span&gt;:
    master merges with remote master
  Local ref configured &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;git push&amp;#39;&lt;/span&gt;:
    master pushes to master &lt;span class="o"&gt;(&lt;/span&gt;up to date&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要重命名引用的名字可以运行 git remote rename 去修改远程仓库的简写名&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote rename me mellisuga
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 me/master 的现在会引用 mellisuga/master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要移除远程仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote rm mellisuga
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 可以给历史中的某个提交打上标签，以示重要。 比较有代表性的是使用这个功能来标记发布结点（v1.0 等等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出标签&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git tag
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;附注标签&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git tag -a v0.1 -m &lt;span class="s1"&gt;&amp;#39;my first version 0.1&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-m 选项指定了一条将会存储在标签中的信息。&lt;/p&gt;
&lt;p&gt;使用 git show 命令可以看到标签信息与对应的提交信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git show v0.1
tag v0.1
Tagger: Ellery &amp;lt;allotory@msn.com&amp;gt;
Date:   Sat Jan &lt;span class="m"&gt;23&lt;/span&gt; 21:35:49 &lt;span class="m"&gt;2016&lt;/span&gt; +0800
my first version v0.1
…
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。&lt;/p&gt;
&lt;p&gt;轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a 、 -s 或 -m 选项，只需要提供标签名字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git tag v0.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在标签上运行 git show ，你不会看到额外的标签信息。 命令只会显示出提交信息。&lt;/p&gt;
&lt;p&gt;可以对过去的提交打标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git tag -a v0.01 5593b
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如不使用 -m 选项时，会默认调用 vim 编辑器编辑标签信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下， git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。- 你可以运行 git push origin [tagname]&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin v0.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin --tags
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建新分支&lt;/p&gt;
&lt;p&gt;创建新分支只是为你创建了一个个可以移动的新的指针。如，创建一个 iss53 分支， 你需要使用 git branch 命令&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/11_basic_branching_1.png" /&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这会在当前所在的提交对象上创建一个指针 iss53&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/11_basic_branching_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;Git 区分当前实在哪个分支上时，使用的是一个名为 HEAD 的特殊指针。指向当前所在的本地分支（可以将 HEAD 想象为当前分支的别名）。&lt;/p&gt;
&lt;p&gt;此时HEAD指针仍然在 master 分支上。 因为 git branch 命令仅仅创建一个新分支，并不会自动切换到新分支中去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换到一个已存在的分支，你需要使用 git checkout 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样 HEAD 就指向 iss53 分支了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以简单地使用 git log 命令查看分叉历史。它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git log --oneline --decorate --graph --all
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout -b iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它是下面两条命令的简写&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch iss53
&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支合并，当 iss53 分支进行修改并提交后，可以将其与 master 分支合并，需要先切换到 master 分支，然后调用 git merge命令合并分支。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout master
&lt;span class="nv"&gt;$ &lt;/span&gt;git merge iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你试图合并两个分支时，如果顺着这个分分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch -d iss53
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。在合并它们的时候就会产生合并冲突，此时 Git 做了合并，但是没有主动地创建一个新的合并提交。&lt;/p&gt;
&lt;p&gt;任何因包含合并冲突而有待解决的文件，都会以未合并状态（unmerged）标识出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分支管理&lt;/p&gt;
&lt;p&gt;查看分支列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果需要查看每个分支的最后一次提交，可以运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch -v
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;--merged 与 --no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。&lt;/p&gt;
&lt;p&gt;如果分支包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败，如果需要可以使用 -D参数强制删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程引用（origin）是对远程仓库的引用（指针），包括分支、标签等，来显式地获得远程引用的完整列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git ls-remote (remote-name)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git remote show (remote-name)
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。它们以 (remote)/(branch) 形式命名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程跟踪分支，假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin ，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master 。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;            服务器（被命名） 本地
默认仓库名   origin          -
默认分支名   origin/master   master
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地分支 dev 推送到远程仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在远程仓库希望改名字，可以使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin dev: newname
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/dev ，指向服务器的 dev 分支的引用。&lt;/p&gt;
&lt;p&gt;特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。即，这种情况下，不会有一个新的 dev 分支 - 只有一个不可以修改的 origin/dev 指针。&lt;/p&gt;
&lt;p&gt;可以运行 git merge origin/dev 将这些工作合并到当前所在的分支。&lt;/p&gt;
&lt;p&gt;如果想要在自己的本地 dev 分支上工作，可以将其建立在远程跟踪分支之上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout -b dev origin/dev
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从一个远程跟踪分支检出的一个本地分支会自动创建一个叫做跟踪分支，跟踪分支是与远程分支有直接关系的本地分支。&lt;/p&gt;
&lt;p&gt;当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。&lt;/p&gt;
&lt;p&gt;可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout --track origin/serverfix
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将本地分支与远程分支设置为不同名字，本地分支 sf 会自动从 origin/serverfix 拉取。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout -b sf origin/serverfix
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch -vv
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除远程分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin --delete serverfix
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Git 中整合来自不同分支的修改主要有两种方法： merge 以及 rebase 。&lt;/p&gt;
&lt;p&gt;开发任务分叉到两个不同分支，又各自提交了更新。&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/12_basic_rebase_1.png" /&gt;&lt;/p&gt;
&lt;p&gt;整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/12_basic_rebase_2.png" /&gt;&lt;/p&gt;
&lt;p&gt;还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout experiment
&lt;span class="nv"&gt;$ &lt;/span&gt;git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged &lt;span class="nb"&gt;command&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/12_basic_rebase_3.png" /&gt;&lt;/p&gt;
&lt;p&gt;现在回到 master 分支，进行一次快进合并。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout master
&lt;span class="nv"&gt;$ &lt;/span&gt;git merge experiment
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="screenshot" src="/images/12_basic_rebase_4.png" /&gt;&lt;/p&gt;
&lt;p&gt;两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。&lt;/p&gt;
&lt;p&gt;使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的  experiment ）变基到目标分支（即 master）上。这样做能省去你先切换到 experiment 分支，再对其执行变基命令的多个步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变基也并非完美无缺，要用它得遵守一条准则：&lt;strong&gt;不要对在你的仓库外有副本的分支执行变基&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Git"></category></entry><entry><title>使用Vundle和GitHub管理Vim配置</title><link href="http://allotory.github.io/posts/2016/02/25/vimrc_config/" rel="alternate"></link><updated>2016-02-25T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2016-02-25:posts/2016/02/25/vimrc_config/</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Vim 作为史上最强大的编辑器之一，拥有数以万计的插件。Vim 的生态系统拥有完美的插件机制。Vundle 是现存最好的 Vim 插件管理方案，用 Vundle 管理插件的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动下载安装&lt;/li&gt;
&lt;li&gt;自动更新&lt;/li&gt;
&lt;li&gt;轻松异地重装&lt;/li&gt;
&lt;li&gt;自动清理没用的插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;前提&lt;/h2&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 管理 Vim 插件时，绝大多数插件都是使用的 Github 上的开源库直接安装的，并且配置好的 Vundle 插件也需要使用 Github 进行管理。所以如果在 Windows 上首先需要安装 Git 客户端并了解常用 Git 命令。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;Vim 可以轻松安装在 &lt;code&gt;Windows&lt;/code&gt; 及 &lt;code&gt;*nix&lt;/code&gt; 系统中，但两者的安装目录结构略有不同。所以安装插件时命令格式也略有不同，应该值得注意。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;Windows 系统：&lt;/span&gt;

&lt;span class="x"&gt;    _vimrc  &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;配置文件   &lt;/span&gt;
&lt;span class="x"&gt;    vmfiles &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;插件目录   对应变量   &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VIM&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;Unix-like 系统：&lt;/span&gt;

&lt;span class="x"&gt;    .vimrc  &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;配置文件&lt;/span&gt;
&lt;span class="x"&gt;    .vim    &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;插件目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;在 Github 上创建 Vim 管理仓库&lt;/h3&gt;
&lt;p&gt;在 Github 上创建一个空白仓库作为 Vim 管理仓库，这样在我们更换系统环境时可以轻松重新恢复已有配置。例如我的仓库为 &lt;a href="https://github.com/allotory/doricha"&gt;doicha&lt;/a&gt;。该仓库的传输协议地址为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git@github.com:allotory/doricha.git
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Vundle 安装（Windows 版本为例）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;备份 Vim 主目录中的 &lt;code&gt;_vimrc&lt;/code&gt; 文件以及 &lt;code&gt;vimfiles&lt;/code&gt; 目录（这点非常重要！）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;git clone&lt;/code&gt; 命令克隆先前创建的 Vim 管理仓库，该例子中为了与 Vim 原始目录名称一致方便管理，所以直接克隆到 &lt;code&gt;vimfiles&lt;/code&gt; 目录，其实可以直接克隆到任何地方，只要在配置文件中表明相关路径即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone git@github.com:allotory/doricha.git vimfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换到 &lt;code&gt;vimfiles&lt;/code&gt; 目录下使用 &lt;code&gt;git submodule add&lt;/code&gt; 命令以 &lt;a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules"&gt;子模块&lt;/a&gt;的形式安装 Vundle。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule add https://github.com/VundleVim/Vundle.vim.git bundle/vundle
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本例中新建了两个新的配置文件 &lt;code&gt;vundle_vimrc&lt;/code&gt; 和 &lt;code&gt;basic_vimrc&lt;/code&gt; ，分别用来保存自定义的 Vundle 配置和自定义的 Vim 基础的配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 &lt;code&gt;vundle_vimrc&lt;/code&gt; 文件具体内容请参考 Vundle 配置文档，其中应重点注意 &lt;code&gt;path&lt;/code&gt; 路径问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;set nocompatible        &amp;quot; be iMproved, required&lt;/span&gt;
&lt;span class="x"&gt;filetype off            &amp;quot; required&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 设置包括vundle和初始化相关的runtime path&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 判断操作系统类型&lt;/span&gt;
&lt;span class="x"&gt;if(has(&amp;#39;win32&amp;#39;) || has(&amp;#39;win64&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;    set rtp+=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VIM&lt;/span&gt;&lt;span class="x"&gt;/vimfiles/bundle/Vundle.vim&lt;/span&gt;
&lt;span class="x"&gt;    let path=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VIM&lt;/span&gt;&lt;span class="x"&gt;/vimfiles/bundle&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;else&lt;/span&gt;
&lt;span class="x"&gt;    set rtp+=~/.vim/bundle/Vundle.vim&lt;/span&gt;
&lt;span class="x"&gt;    let path=&amp;#39;~/.vim/bundle&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;endif&lt;/span&gt;
&lt;span class="x"&gt;call vundle&lt;/span&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 另一种选择, 指定一个vundle安装插件的路径&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;call vundle&lt;/span&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/some/path/here&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 让vundle管理插件版本,必须&lt;/span&gt;
&lt;span class="x"&gt;Plugin &amp;#39;VundleVim/Vundle.vim&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 以下范例用来支持不同格式的插件安装.&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 请将安装插的命令放在vundle&lt;/span&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="x"&gt;和vundle&lt;/span&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="x"&gt;之间.&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; Github上的插件&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 格式为 Plugin &amp;#39;用户名/插件仓库名&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; Plugin &amp;#39;插件名称&amp;#39; 实际上是 Plugin &amp;#39;vim-scripts/插件仓库名&amp;#39; 只是此处的用户名可以省略&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;L9&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 由Git支持但不再github上的插件仓库 Plugin &amp;#39;git clone 后面的地址&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;git://git.wincent.com/command-t.git&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 本地的Git仓库(例如自己的插件) Plugin &amp;#39;file:///+本地插件仓库绝对路径&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 插件在仓库的子目录中.&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 避免插件名冲突,例如L9已存在,则可以指定&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;Plugin &amp;#39;user/L9&amp;#39;, &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;&amp;#39;name&amp;#39;: &amp;#39;newL9&amp;#39;}&lt;/span&gt;

&lt;span class="x"&gt;&amp;quot; 你的所有插件需要在下面这行之前&lt;/span&gt;
&lt;span class="x"&gt;call vundle&lt;/span&gt;&lt;span class="cp"&gt;#&lt;/span&gt;&lt;span class="nf"&gt;end&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="x"&gt;            &amp;quot; 必须&lt;/span&gt;
&lt;span class="x"&gt;filetype plugin indent on    &amp;quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 忽视插件改变缩进,可以使用以下替代:&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;filetype plugin on&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 简要帮助文档&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; :PluginList       - 列出所有已配置的插件&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; :PluginInstall    - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 将你自己对非插件片段放在这行之后&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 &lt;code&gt;baisc_vimrc&lt;/code&gt; 文件，这里提供了我自己常用的一些配置仅供参考。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;set nocompatible

&amp;quot; 主题
colorscheme molokai
let g:molokai_original = 1

&amp;quot; 基础设置
set guifont=Monaco:h14          &amp;quot; 字体 &amp;amp;&amp;amp; 字号
syntax on                       &amp;quot; 打开语法高亮
set number                      &amp;quot; 显示行号
set autoindent                  &amp;quot; 设置缩进有三个取值 cindent (c风格)
                                &amp;quot; smartindent (智能模式)、
                                &amp;quot; autoindent (简单的与上一行保持一致)
set tabstop=4                   &amp;quot; 设置 tab 键的宽度
set shiftwidth=4                &amp;quot; 换行时行间交错使用4个空格
set backspace=indent,eol,start  &amp;quot; 设置退格键可用
                                &amp;quot; indent：如果用了 set indent, set ai 等自动缩进，想用退格键将字段缩进的删掉，必须设置这个选项，否则不响应。
                                &amp;quot; eol：如果插入模式下在行开头，想通过退格键合并两行，需要设置eol。
                                &amp;quot; start：要想删除此次插入前的输入，需设置这个。
set smarttab                    &amp;quot; 每次按 backspace 时删除4个空格
set incsearch                   &amp;quot; 增量式搜索(遍搜索遍显示内容)
set hlsearch                    &amp;quot; 高亮搜索
filetype on                     &amp;quot; 打开文件类型检测功能
filetype plugin on              &amp;quot; 允许加载文件类型插件
filetype indent on              &amp;quot; 允许为不同类型的文件定义不同的缩进格式
set showmatch                   &amp;quot; 显示括号配对情况
&amp;quot;set foldenable                 &amp;quot; 开启代码折叠
&amp;quot;set foldmethod=syntax          &amp;quot; 自动语法折叠
set nobackup                    &amp;quot; 禁止生成备份
set noswapfile                  &amp;quot; 不产生 swp 文件
set mouse=a                     &amp;quot; 启用鼠标
set nowrap                      &amp;quot; 设置不自动折行
set cursorline                  &amp;quot; 突出显示当前行
set clipboard=unnamed           &amp;quot; 与 windows 共享剪贴板
set cmdheight=1                 &amp;quot; 命令行（在状态行下）的高度，默认为1
set laststatus=2                &amp;quot; 开启状态栏信息

&amp;quot; 设置窗口
if has(&amp;quot;gui_running&amp;quot;)
    &amp;quot; au GUIEnter * simalt ~x   &amp;quot; 窗口启动时自动最大化
    winpos 70 25                &amp;quot; 指定窗口出现的位置，坐标原点在屏幕左上角
    set lines=55 columns=180    &amp;quot; 指定窗口大小，lines 为高度，columns 为宽度
    set guioptions+=c           &amp;quot; 使用字符提示框
    set guioptions-=m           &amp;quot; 隐藏菜单栏
    set guioptions-=T           &amp;quot; 隐藏工具栏
    set guioptions=L            &amp;quot; 隐藏左侧滚动条
    set guioptions=r            &amp;quot; 隐藏右侧滚动条
    set guioptions-=b           &amp;quot; 隐藏底部滚动条
    set showtabline=0           &amp;quot; 隐藏 Tab 栏
endif

&amp;quot; 设置编码
set fenc=utf-8                              &amp;quot; 设置编码
set encoding=utf-8                          &amp;quot; 内部的程序识别编码
set fileencoding=utf-8                      &amp;quot; 当前文件编辑时使用的文件编码
set fileencodings=utf-8,gbk,cp936,latin-1   &amp;quot; gvim 打开文件是支持的编码
language messages zh_CN.utf-8               &amp;quot; 解决 consle 输出乱码
set ambiwidth=double                        &amp;quot; 防止特殊符号无法显示
set helplang=cn                             &amp;quot; 中文帮助
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后将我们自定义的配置文件引入到 Vim 的配置文件 &lt;code&gt;_vimrc&lt;/code&gt; 中， 同样注意其中路径写法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;&amp;quot; 引用自定义的vundle配置文件,存放vimrc的地方(不是固定写法，可自定义)&lt;/span&gt;
&lt;span class="x"&gt;&amp;quot; 判断操作系统类型&lt;/span&gt;
&lt;span class="x"&gt;if(has(&amp;#39;win32&amp;#39;) || has(&amp;#39;win64&amp;#39;))&lt;/span&gt;
&lt;span class="x"&gt;    source &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VIM&lt;/span&gt;&lt;span class="x"&gt;/vimfiles/vundle_vimrc&lt;/span&gt;
&lt;span class="x"&gt;    source &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VIM&lt;/span&gt;&lt;span class="x"&gt;/vimfiles/basic_vimrc&lt;/span&gt;
&lt;span class="x"&gt;else&lt;/span&gt;
&lt;span class="x"&gt;    source ~/.vim/vundle_vimrc&lt;/span&gt;
&lt;span class="x"&gt;    source ~/.vim/basic_vimrc&lt;/span&gt;
&lt;span class="x"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，我们已经完成 Vundle 安装。&lt;/p&gt;
&lt;h3&gt;插件安装&lt;/h3&gt;
&lt;p&gt;Vundle 安装完成后，就可以使用其进行其他插件的安装。这里我们以 &lt;a href="https://github.com/scrooloose/nerdtree"&gt;NERDTree&lt;/a&gt; 为例，&lt;code&gt;NERDTree&lt;/code&gt; 是一个非常好用的 Vim 树形浏览插件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;vundle_vimrc&lt;/code&gt; 中 &lt;code&gt;Github&lt;/code&gt; 插件部分添加如下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Plugin &amp;#39;scrooloose/nerdtree&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新打开 Vim 命令模式下执行如下命令即可完成安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;：PluginInstall
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;basic_vimrc&lt;/code&gt; 中按需要自行配置 &lt;code&gt;NERDTree&lt;/code&gt;， 如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;autocmd vimenter * NERDTree
let NERDTreeWinSize=25
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;将已安装的插件以子模块形式进行管理&lt;/h3&gt;
&lt;p&gt;最初我们安装 Vundle 时是以 &lt;code&gt;Git&lt;/code&gt; 子模块形式进行管理的，但是使用 Vundle 安装的插件并没有以子模块形式进行管理，所以为了方便日后更新管理插件，需要手动将其添加为子模块。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule add https://github.com/scrooloose/nerdtree.git bundle/nerdtree
Adding existing repo at &lt;span class="s1"&gt;&amp;#39;bundle/nerdtree&amp;#39;&lt;/span&gt; to the index
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时我们已经完成了所有的安装配置操作，可以正常的提交到 &lt;code&gt;Github&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;重新安装（Windows 版本为例）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;克隆主项目到 &lt;code&gt;vimfiles&lt;/code&gt; 目录。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone git@github.com:allotory/doricha.git vimfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时，所有的插件目录均为空，需要重新安装，这是可以使用三种方法安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 Vundle 命令安装，这种方法需要重新安装 Vundle。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule add https://github.com/VundleVim/Vundle.vim.git bundle/vundle
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后再使用 Vundle 命令重新安装其他插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;：PluginInstall
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于之前所有插件均添加为主项目的子模块，所以可以使用 &lt;code&gt;Git&lt;/code&gt; 子模块相关命令进行安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule —-查看当前项目用到的子模块
&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule init —-只在首次检出仓库时运行一次就行
&lt;span class="nv"&gt;$ &lt;/span&gt;git submodule update —-更新子模块（子模块会重新检出）
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更简单的一种方法是克隆主仓库时将其所包含的子模块同时克隆下来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; $ git clone --recursive git@github.com:allotory/doricha.git vimfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后不要忘了将我们自定义的配置文件引入到 Vim 的配置文件 &lt;code&gt;_vimrc&lt;/code&gt; 中，因为此时的 &lt;code&gt;_vimrc&lt;/code&gt; 文件是全新的，需要重新设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Vim 是一个神器，但用好不宜。个人觉得不应该安装过多的插件使其成为一个 IDE ，过多的插件会使 Vim 卡顿、启动缓慢等。反而不如真正的 IDE 好用。最后附上我的界面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/10-vim-vundle-config.png" /&gt;&lt;/p&gt;</summary><category term="Vim"></category><category term="GitHub"></category></entry><entry><title>Java MessageDiges使用</title><link href="http://allotory.github.io/posts/2015/01/07/java-message-digest/" rel="alternate"></link><updated>2015-01-07T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2015-01-07:posts/2015/01/07/java-message-digest/</id><summary type="html">&lt;h2&gt;MessageDigest简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.security.MessageDigest&lt;/code&gt; 类用于为应用程序提供信息摘要算法的功能，如 &lt;code&gt;MD5&lt;/code&gt; 或 &lt;code&gt;SHA&lt;/code&gt; 算法。简单点说就是用于生成散列码。信息摘要是安全的单向哈希函数，它接收任意大小的数据，输出固定长度的哈希值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessageDigest&lt;/code&gt; 通过其 &lt;code&gt;getInstance&lt;/code&gt; 系列静态函数来进行实例化和初始化。&lt;code&gt;MessageDigest&lt;/code&gt; 对象通过使用 &lt;code&gt;update&lt;/code&gt; 方法处理数据。任何时候都可以调用 &lt;code&gt;reset&lt;/code&gt; 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 &lt;code&gt;digest&lt;/code&gt; 方法之一完成哈希计算并返回结果。&lt;/p&gt;
&lt;p&gt;对于给定数量的更新数据，&lt;code&gt;digest&lt;/code&gt; 方法只能被调用一次。&lt;code&gt;digest&lt;/code&gt; 方法被调用后，&lt;code&gt;MessageDigest&lt;/code&gt; 对象被重新设置成其初始状态。&lt;/p&gt;
&lt;h2&gt;实例&lt;/h2&gt;
&lt;p&gt;1.创建 MessageDigest 对象&lt;/p&gt;
&lt;p&gt;计算信息摘（即散列码）要做的第一步是创建 &lt;code&gt;MessageDigest&lt;/code&gt; 对象实例。像所有的引擎类一样，获取某类报文摘要算法（即散列算法，比如MD5）的 &lt;code&gt;MessageDigest&lt;/code&gt; 对象的途径是调用 &lt;code&gt;MessageDigest&lt;/code&gt; 类中的 &lt;code&gt;getInstance&lt;/code&gt; 静态 &lt;code&gt;factory&lt;/code&gt; 方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    public static MessageDigest getInstance(String algorithm)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注：算法名不区分大小写。即&lt;code&gt;md5&lt;/code&gt;等价于&lt;code&gt;MD5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2.向 MessageDigest 传递数据&lt;/p&gt;
&lt;p&gt;计算数据的摘要的第二步是向已初始化的 &lt;code&gt;MessageDigest&lt;/code&gt; 对象提供传送要计算的数据。这将通过一次或多次调用以下某个 &lt;code&gt;update&lt;/code&gt;（更新）方法来完成。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    public void update(byte input);
    public void update(byte[] input);
    public void update(byte[] input, int offset, int len);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.计算摘要
通过调用 &lt;code&gt;update&lt;/code&gt; 方法向 &lt;code&gt;MessageDigest&lt;/code&gt; 对象提传送要计算的数据后，你就可以调用以下某个 &lt;code&gt;digest&lt;/code&gt;（摘要）方法来计算摘要（即生成散列码）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    public byte[] digest();
    public byte[] digest(byte[] input);
    public int digest(byte[] buf, int offset, int len);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前两个方法返回计算出的摘要。后一个方法把计算出的摘要储存在所提供的 &lt;code&gt;buf&lt;/code&gt; 缓冲区中，起点是 &lt;code&gt;offset&lt;/code&gt;。&lt;code&gt;len&lt;/code&gt; 是 &lt;code&gt;buf&lt;/code&gt; 中分配给该摘要的字节数。该方法返回实际存储在 &lt;code&gt;buf&lt;/code&gt; 中的字节数。
对第二个接受输入字节数组变量的 &lt;code&gt;digest&lt;/code&gt; 方法的调用等价于用指定的输入调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    public void update(byte[] input)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;测试源码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.UnsupportedEncodingException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.security.MessageDigest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.security.NoSuchAlgorithmException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Encryption&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;encryptionPwd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;algorithm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;resultData&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;MessageDigest&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;创建&lt;/span&gt;  &lt;span class="n"&gt;MessageDigest&lt;/span&gt; &lt;span class="err"&gt;对象&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;调用&lt;/span&gt; &lt;span class="n"&gt;MessageDigest&lt;/span&gt; &lt;span class="err"&gt;类中的&lt;/span&gt; &lt;span class="n"&gt;getInstance&lt;/span&gt; &lt;span class="err"&gt;静态&lt;/span&gt; &lt;span class="n"&gt;factory&lt;/span&gt; &lt;span class="err"&gt;方法&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;算法名不区分大小写&lt;/span&gt;
                &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;algorithm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;向&lt;/span&gt;&lt;span class="n"&gt;MessageDigest&lt;/span&gt;&lt;span class="err"&gt;传送要计算的数据&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="err"&gt;传入的参数是字节类型或字节类型数组，&lt;/span&gt;
                &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;对于字符串，需要先使用&lt;/span&gt;&lt;span class="n"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;方法生成字符串数组。&lt;/span&gt;
                &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getBytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;UTF8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
                &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;计算摘要&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;生成散列码&lt;/span&gt;
                &lt;span class="n"&gt;resultData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NoSuchAlgorithmException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnsupportedEncodingException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;convertToHexString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;resultData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;将计算结果&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt;&lt;span class="err"&gt;数组&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;转换为字符串&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;convertToHexString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;StringBuffer&lt;/span&gt; &lt;span class="n"&gt;strBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuffer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;strBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toHexString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xff&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;strBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Java"></category><category term="Security"></category></entry><entry><title>Python time,datetime,string转换</title><link href="http://allotory.github.io/posts/2015/01/07/pelican-time-string/" rel="alternate"></link><updated>2015-01-07T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2015-01-07:posts/2015/01/07/pelican-time-string/</id><summary type="html">&lt;h5&gt;把datetime转换为字符串&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    def datetime_toString(dt):  
        return dt.strftime(&amp;quot;%Y-%m-%d-%H&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;把字符串转换为datetime&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    def string_toDatetime(string):  
         return datetime.strptime(string, &amp;quot;%Y-%m-%d-%H&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;把字符串转会为时间戳&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    def string_toTimestamp(strTime):  
        return time.mktime(string_toDatetime(strTime).timetuple())
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;把时间戳转换为字符串&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    def timestamp_toString(stamp):  
        return time.strftime(&amp;quot;%Y-%m-%d-%H&amp;quot;, tiem.localtime(stamp))
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;把datetime类型转换为时间戳&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    def datetime_toTimestamp(dateTim):  
        return time.mktime(dateTim.timetuple())
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Python"></category></entry><entry><title>Eclipse启动Tomcat访问http://localhost:8080/时报404错误</title><link href="http://allotory.github.io/posts/2015/01/06/eclipse-tomcat-404/" rel="alternate"></link><updated>2015-01-06T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2015-01-06:posts/2015/01/06/eclipse-tomcat-404/</id><summary type="html">&lt;h3&gt;原因&lt;/h3&gt;
&lt;p&gt;Eclipse启动Tomcat服务输入&lt;code&gt;http://localhost:8080/&lt;/code&gt;会报404错误, 即&lt;code&gt;The requested resource (/) is not avaliable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;错误产生的原因在于工作空间的项目部署的目录不对。&lt;/p&gt;
&lt;p&gt;配置Tomcat时, 如果只想运行Eclipse工作空间的应用项目, 可以选择&lt;code&gt;User workspace metadata&lt;/code&gt;, 此时采用的是&lt;code&gt;%ECLIPSE_WORKSPACE_HOME%/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps&lt;/code&gt;作为webapp目录的, wtpwebapps下没有ROOT webapp或者有时包括一个空的ROOT webapp。在这种情况下, 访问&lt;code&gt;http://localhost:8080/&lt;/code&gt;就会看到HTTP error 404或者一个空白页面。&lt;/p&gt;
&lt;p&gt;如果希望同时运行其他Eclipse工作空间之外的应用项目, 就可以选择&lt;code&gt;Use Tomcat installation&lt;/code&gt;。启动Tomcat时, 是采用&lt;code&gt;%TOMCAT_HOME%/webapps&lt;/code&gt;（包括docs，host-manager，manager，ROOT4个目录）作为默认的webapp目录的。&lt;/p&gt;
&lt;h3&gt;解决方法&lt;/h3&gt;
&lt;p&gt;1.打开Eclipse的Server视图, 双击Tomcat Server打开编辑窗口, 找到&lt;code&gt;Server Locations&lt;/code&gt;如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="eclipse_tomcat_404" src="/images/7-eclipse-tomcat-404.png" /&gt;&lt;/p&gt;
&lt;p&gt;2.选择第二项&lt;code&gt;Use Tome installation&lt;/code&gt;,并且根据自己tomcat安装路径来修改&lt;code&gt;Server path&lt;/code&gt;的内容。&lt;/p&gt;
&lt;p&gt;3.如果选项为第一项并且不可选, 可以在Server视图, 右键Properties -&amp;gt; General, 如果&lt;code&gt;Location:[workspace metadata]&lt;/code&gt; ,则单击&lt;code&gt;Switch Location&lt;/code&gt;按钮, 修改为&lt;code&gt;Location:/Servers/Tomcat v8.0 Server at localhost.server&lt;/code&gt;, 应用即可。&lt;/p&gt;</summary><category term="IDE"></category><category term="Server"></category></entry><entry><title>设置IDE移动光标快捷键</title><link href="http://allotory.github.io/posts/2015/01/06/ide-key-setting/" rel="alternate"></link><updated>2015-01-06T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2015-01-06:posts/2015/01/06/ide-key-setting/</id><summary type="html">&lt;h3&gt;Eclipse&lt;/h3&gt;
&lt;p&gt;在Eclipse的一堆快捷键设置中&lt;code&gt;Window -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Keys&lt;/code&gt; 分别找出上下左右命令名称设置为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    Previous Column -&amp;gt; Alt + H      
    Line Up         -&amp;gt; Alt + J
    Line Down       -&amp;gt; Alt + K
    Next Column     -&amp;gt; Alt + L
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Sublime Text&lt;/h3&gt;
&lt;p&gt;在Sublime Text里，打开&lt;code&gt;Preferences -&amp;gt; Key Bindings -&amp;gt; User&lt;/code&gt;设置移动快捷键：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    { &amp;quot;keys&amp;quot;: [&amp;quot;Alt + L&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;characters&amp;quot;, &amp;quot;forward&amp;quot;: true} },
    { &amp;quot;keys&amp;quot;: [&amp;quot;Alt + H&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;characters&amp;quot;, &amp;quot;forward&amp;quot;: false} },
    { &amp;quot;keys&amp;quot;: [&amp;quot;Alt + Space&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;word_ends&amp;quot;, &amp;quot;forward&amp;quot;: true} },
    { &amp;quot;keys&amp;quot;: [&amp;quot;Shift + Alt + Space&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;word_ends&amp;quot;, &amp;quot;forward&amp;quot;: false} },
    { &amp;quot;keys&amp;quot;: [&amp;quot;Alt + K&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;lines&amp;quot;, &amp;quot;forward&amp;quot;: true} },
    { &amp;quot;keys&amp;quot;: [&amp;quot;Alt + J&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;move&amp;quot;, 
        &amp;quot;args&amp;quot;: {&amp;quot;by&amp;quot;: &amp;quot;lines&amp;quot;, &amp;quot;forward&amp;quot;: false} }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;快捷键对照：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    Alt + L                 右移光标一个字符
    Alt + H                 左移光标一个字符
    Alt + Space             右移光标一个单元
    Shift + Alt + Space     左移光标一个单元
    Alt + K                 下移光标一行
    Alt + J                 上移光标一行
&lt;/pre&gt;&lt;/div&gt;</summary><category term="IDE"></category></entry><entry><title>常用Javascript技术</title><link href="http://allotory.github.io/posts/2015/01/06/javascript-skills/" rel="alternate"></link><updated>2015-01-06T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2015-01-06:posts/2015/01/06/javascript-skills/</id><summary type="html">&lt;h3&gt;正则表达式校验数据&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    var username = document.getElementById(&amp;quot;username&amp;quot;).value.trim();
    var reg = /^[a-zA-Z][a-zA-Z0-9_]{5,14}$/;
    if (!reg.test(username)){
        alert(&amp;quot;用户名必须为6-15个以字母开头，可带数字、“_”的字符串&amp;quot;);
    }else {
        alert(&amp;quot;用户名可用&amp;quot;);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下拉列表动态添加选项&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    //根据id查找对象，
    var obj = document.getElementById(&amp;#39;year&amp;#39;);
    //添加一个选项
    obj.add(new Option(&amp;quot;文本&amp;quot;, &amp;quot;值&amp;quot;));         //这个只能在IE中有效
    obj.options.add(new Option(&amp;quot;文本&amp;quot;, &amp;quot;值&amp;quot;)); //这个兼容IE与firefox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;动态添加组件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    var error = document.createElement(&amp;quot;div&amp;quot;);
    error.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;err_div&amp;quot;);
    error.setAttribute(&amp;quot;class&amp;quot;, &amp;quot;alert bg-success&amp;quot;);

    var divSpan = document.createElement(&amp;quot;span&amp;quot;);
    divSpanSign.setAttribute(&amp;quot;class&amp;quot;, &amp;quot;glyphicon glyphicon-warning-sign&amp;quot;);

    error.appendChild(divSpan);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;动态删除组件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    document.getElementById(&amp;quot;alert_errors&amp;quot;).removeChild(document.getElementById(&amp;quot;id&amp;quot;));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;innerText兼容firefox&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;setInnerText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;element&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;element&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;element&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;innerText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;实现 JavaScript trim() 方法&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prototype&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;trim&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/(^\s*)|(\s*$)/g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;用户名唯一性校验&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;//定义XMLHttpRequest对象  &lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//用户名唯一性校验&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;checkUsernameUniqueness&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getElementById&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;trim&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;//创建XMLHttpRequest对象  &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;XMLHttpRequest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="c1"&gt;//针对FireFox,Mozillar,Opera,Safari,IE7,IE8  &lt;/span&gt;
            &lt;span class="nx"&gt;xmlhttp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;XMLHttpRequest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
            &lt;span class="c1"&gt;//对某些特定版本的mozillar浏览器的bug进行修正  &lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;overrideMineType&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
                &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;overrideMineType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;text/xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
            &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ActiveXObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="c1"&gt;//针对IE5，IE5.5，IE6  &lt;/span&gt;
            &lt;span class="c1"&gt;//两个可以用于创建XMLHTTPRequest对象的控件名称。保存在一个JS数组中。  &lt;/span&gt;
            &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;activexName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MSXML2.XMLHTTP&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Microsoft.XMLHTTP&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;activeName&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
                &lt;span class="c1"&gt;//取出一个控件名进行创建，如果成功就终止循环  &lt;/span&gt;
                &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
                    &lt;span class="nx"&gt;xmlhttp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;ActiveXObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;activexName&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;An exception occured in the script.Error name: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;
                            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;.Error message: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;  
            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;//注册回调函数,只写函数名，不能写括号，写括号表示调用函数。  &lt;/span&gt;
        &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;onreadystatechange&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;usernameUniqueCallback&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="c1"&gt;//设置连接信息(请求方式，请求的url,true表示异步方式交互)  &lt;/span&gt;
        &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;UserCheck?username=&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//发送数据，开始和服务器进行交互。  &lt;/span&gt;
        &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//使用POST方式请求，需要手动设置http的请求头  &lt;/span&gt;
        &lt;span class="c1"&gt;//xmlhttp.setRequestHeader(&amp;quot;Content-Type&amp;quot;,&amp;quot;aplication/x-www-form-urlencoded&amp;quot;);  &lt;/span&gt;
        &lt;span class="c1"&gt;//xmlhttp.send(&amp;quot;name=&amp;quot; + username);  &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//用户名唯一性校验回调函数  &lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;usernameUniqueCallback&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
        &lt;span class="c1"&gt;//判断对象的状态是否交互完成  &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;readyState&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
            &lt;span class="c1"&gt;//判断http的交互是否成功  &lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;status&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
                &lt;span class="c1"&gt;//获取服务器端返回的数据（文本）  &lt;/span&gt;
                &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;responseText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;xmlhttp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;responseText&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="c1"&gt;//alert(responseText);&lt;/span&gt;

                &lt;span class="c1"&gt;//用户名不唯一&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseText&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="c1"&gt;//输出提示信息&lt;/span&gt;
                    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;用户名已存在&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;responseText&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;用户名可用&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;哎呀，出错啦～&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;回调函数UserCheck Servlet:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.IOException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.PrintWriter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.servlet.ServletException&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.servlet.annotation.WebServlet&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.servlet.http.HttpServlet&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.servlet.http.HttpServletRequest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;javax.servlet.http.HttpServletResponse&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.archilochus.bean.User&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.archilochus.dao.UserDAOImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@WebServlet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/UserCheck&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UserCheck&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;HttpServlet&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="nb"&gt;long&lt;/span&gt; &lt;span class="n"&gt;serialVersionUID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="il"&gt;1L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;UserCheck&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doGet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HttpServletRequest&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HttpServletResponse&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
                &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;ServletException&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
             &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
                    &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCharacterEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                    &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setContentType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/html; charset=utf-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                    &lt;span class="n"&gt;PrintWriter&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getWriter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
                    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getParameter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                    &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;数据库查询&lt;/span&gt;
                    &lt;span class="n"&gt;UserDAOImpl&lt;/span&gt; &lt;span class="n"&gt;userDAOImpl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;UserDAOImpl&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                    &lt;span class="n"&gt;User&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                    &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setUsername&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                 &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;userDAOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findUserByName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;  
                     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;不唯一&lt;/span&gt;
                     &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                 &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                     &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                 &lt;span class="p"&gt;}&lt;/span&gt;
             &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;  
                 &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
             &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doPost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HttpServletRequest&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;HttpServletResponse&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
                &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;ServletException&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IOException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Javascript"></category></entry><entry><title>Django 1.7 使用migrations建立数据库连接</title><link href="http://allotory.github.io/posts/2014/09/28/django-migrations/" rel="alternate"></link><updated>2014-09-28T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2014-09-28:posts/2014/09/28/django-migrations/</id><summary type="html">&lt;p&gt;Django1.7 采用了全新的APP加载框架，校验框架，数据查询优化，并且还自带整合了&lt;code&gt;django-south&lt;/code&gt;的（数据库）迁移功能，其提供的&lt;code&gt;django-admin migrate&lt;/code&gt;也将代替&lt;code&gt;syncdb&lt;/code&gt;命令.&lt;/p&gt;
&lt;p&gt;因此在我们建立数据库模型之后，就不能使用django的&lt;code&gt;syncdb&lt;/code&gt;命令同步数据库了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;python manage.py syncdb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则数据库模型将不会同步到真正的数据库中。
&lt;!-- PELICAN_END_SUMMARY --&gt;
在Django 1.7中使用将使用全新的&lt;code&gt;migrations&lt;/code&gt;同步数据库。建立数据库模型后使用命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;python manage.py makemigrations west
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建migrations，成功显示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Migrations for &amp;#39;west&amp;#39;:
    0001_initial.py:
    - Create model Character
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;sqlmigrate&lt;/code&gt;命令查看sql语句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;python manage.py sqlmigrate west 0001
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后使用&lt;code&gt;migrate&lt;/code&gt;命令同步数据库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;python manage.py migrate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时数据库模型已经真正的同步到数据库中了。&lt;/p&gt;</summary><category term="Django"></category><category term="Python"></category></entry><entry><title>解决Django同步数据库No module named MySQLdb错误</title><link href="http://allotory.github.io/posts/2014/09/24/django-syncdb/" rel="alternate"></link><updated>2014-09-24T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2014-09-24:posts/2014/09/24/django-syncdb/</id><summary type="html">&lt;p&gt;Django在同步数据库时会根据&lt;code&gt;models.py&lt;/code&gt;中描述的数据模型，在MySQL中创建各个关系表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;python manage.py syncdb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同步数据库后，Django将建立相关的MySQL表格，并要求你创建一个超级用户等信息，但有时在windows环境下执行上述命令后会提示出错信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;django.core.exceptions.ImproperlyConfigured: 
Error loading MySQLdb module: No module named MySQLdb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No model named Mysqldb，这是因为当前Python环境没有安装&lt;code&gt;MySQL for Python&lt;/code&gt;组件，解决办法：下载相应&lt;a href="http://sourceforge.net/projects/mysql-python/files/mysql-python-test/"&gt;MySQL for Python组件&lt;/a&gt;并安装即可。&lt;/p&gt;</summary><category term="Django"></category><category term="MySQL"></category></entry><entry><title>修复Pelican代码块中红框问题</title><link href="http://allotory.github.io/posts/2014/09/08/fix-code-err/" rel="alternate"></link><updated>2014-09-08T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2014-09-08:posts/2014/09/08/fix-code-err/</id><summary type="html">&lt;p&gt;在使用Markdown的代码块时，如果代码中有汉字或者按规定书写错误的代码，则生成的HTML文件中错误的代码会有红框框住。
在Pelican中使用&lt;code&gt;pygment.css&lt;/code&gt;文件处理代码高亮，我们可以修改该文件修复红框问题。可以修改&lt;code&gt;output/theme/pygment.css&lt;/code&gt;处理该问题，但是当我们重新调用&lt;code&gt;make html&lt;/code&gt;时，文件会被重置，所以可以修改博客根目录下&lt;code&gt;pelican-themes&lt;/code&gt;里的&lt;code&gt;pygment.css&lt;/code&gt;文件。如本博客为&lt;code&gt;Amazilia\pelican-themes\gum\static&lt;/code&gt;下的&lt;code&gt;pygment.css&lt;/code&gt;。找到如下代码去掉即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;.err&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;border:&lt;/span&gt;&lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="nf"&gt;px&lt;/span&gt; &lt;span class="no"&gt;solid&lt;/span&gt; &lt;span class="c"&gt;#FF0000;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="CSS"></category><category term="Pelican"></category><category term="Markdown"></category></entry><entry><title>使用Pelican和GitHub搭建个人博客</title><link href="http://allotory.github.io/posts/2014/09/08/pelican-install/" rel="alternate"></link><updated>2014-09-08T00:00:00+08:00</updated><author><name>Ellery</name></author><id>tag:allotory.github.io,2014-09-08:posts/2014/09/08/pelican-install/</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Github是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。GitHub设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。&lt;/p&gt;
&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;p&gt;搭建博客使用的工具是基于Python的Pelican。相对于WordPress，Pelican有着轻便小巧的特性，与GitHub Pages搭配很完美。当然其他的工具如Jeklly也非常棒，基于octopress相当的不错，可惜都是基于ruby语言的，对ruby语言压根就不了解，并且最近一直在学习Python，所以最终选择了基于Python的Pelican。
&lt;!-- PELICAN_END_SUMMARY --&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gihub.com/"&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/"&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.python.org/"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi"&gt;Pip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;Pelican&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;下载安装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.python.org/getit/"&gt;Python下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://msysgit.github.io/"&gt;Git下载&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/distribute#downloads"&gt;Pip下载&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.equation.com/servlet/equation.cmd?fa=make"&gt;Windows下make下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;安装Python，本文使用的是Python 2.7&lt;/li&gt;
&lt;li&gt;安装Git，Git简单教程参见&lt;a href="http://www.git-scm.com/book/zh"&gt;Git教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;将Python安装文件夹中的scripts和make.exe加入环境变量&lt;/li&gt;
&lt;li&gt;安装pip，具体可以看&lt;a href="http://www.pip-installer.org/en/latest/installing.html"&gt;官网介绍&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装pelican和markdown，具体请参见&lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;markdown教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;pip install pelican
pip install markdown&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;开始搭建博客&lt;/h2&gt;
&lt;p&gt;打开Git bash，创建一个文件夹&lt;code&gt;Amazilia&lt;/code&gt;（可以按喜好拟定），执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir Amazilia
cd Amazilia
pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行完pelican-quickstart命令后，会提示博客的配置选项，除少数几项必填之外，其他可以选择默认，如有需要可以在&lt;code&gt;pelicanconf.py&lt;/code&gt;文件中可以进行修改。
命令成功执行后，会出现Pelican框架，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Amazilia/
├── content                # 存放输入的markdown源文件
│   └── (pages)            # 存放手工创建的静态页面，可选
├── output                 # 存放最终生成的静态博客
├── develop_server.sh      # 测试服务器
├── Makefile               # 管理博客的Makefile
├── pelicanconf.py         # 配置文件
└── publishconf.py         # 发布文件，可删除
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;撰写博客&lt;/h2&gt;
&lt;p&gt;完成博客主体搭建后，可以使用Sublime Text创建一个&lt;code&gt;.md&lt;/code&gt;文件，使用markdown语法书写博客，完成后保存于&lt;code&gt;content&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Title: 使用Pelican和GitHub搭建个人博客
Date: 2014-09-08
Tags: Python, Pelican, GitHub, Markdown
Category: Pelican
Slug: pelican-install
Author: Ellery
###简介
Github是一个具有版本管理功能的代码仓库，每个项目都有一个主页，列出项目的源文件。GitHub设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成之后，在&lt;code&gt;Amazilia&lt;/code&gt;目录下，执行&lt;code&gt;make html&lt;/code&gt;命令生成博客&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make html
(pelican e:/blog/content/ -o e:/blog/output -s e:/blog/pelicanconfg.py)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;make html&lt;/code&gt;命令是将&lt;code&gt;.md&lt;/code&gt;文件生成HTML，存放在&lt;code&gt;output&lt;/code&gt;目录下，如果没有&lt;code&gt;make&lt;/code&gt;命令，可以使用第二行的&lt;code&gt;Pelican&lt;/code&gt;命令。
接着执行&lt;code&gt;make serve&lt;/code&gt;命令开启测试服务器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make serve
(cd e:/blog/output/ &amp;amp;&amp;amp; python -m pelican.server)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样&lt;code&gt;make serve&lt;/code&gt;命令也可以由第二行的&lt;code&gt;Pelican&lt;/code&gt;命令替代，在浏览器中输入&lt;code&gt;http://localhost:8000&lt;/code&gt;即可看到博文效果。&lt;/p&gt;
&lt;h2&gt;配置主题&lt;/h2&gt;
&lt;p&gt;在Amazilia目录下，按照如下步骤下载Pelican主题，只挑选喜欢的即可，其他不喜欢的可以删掉。主题可以在&lt;a href="https://github.com/getpelican/pelican-themes"&gt;Pelican主题库&lt;/a&gt;查看。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone https://github.com/getpelican/pelican-themes.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;，更改或添加&lt;code&gt;THEME&lt;/code&gt;为自己喜欢的主题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;THEME = &amp;#39;pelican-themes/threnetes&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当前主题threnetes是我自用的主题，如果喜欢请到github下载&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;https://github.com/allotory/threnetes
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;添加评论系统&lt;/h2&gt;
&lt;p&gt;在&lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt;上注册，按照流程Disqus会分配给站点一个&lt;code&gt;Shortname&lt;/code&gt;，然后修改&lt;code&gt;pelicanconf.py&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;DISQUS_SITENAME=Shortname
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;发布博客&lt;/h2&gt;
&lt;p&gt;在github上面建立一个&lt;code&gt;当前github用户名.github.io&lt;/code&gt;的版本仓库，如我博客版本仓库的为&lt;code&gt;allotory.github.io&lt;/code&gt;，然后进入&lt;code&gt;output&lt;/code&gt;目录下，依次执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git init
git remote add origin git@github.com:allotory/allotory.github.io.git
git pull origin master
git commit -m &amp;#39;first blog&amp;#39;
git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此完成博客发布，访问&lt;code&gt;allotory.github.io&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2&gt;Google Analytics&lt;/h2&gt;
&lt;p&gt;注册&lt;a href="https://www.google.com/analytics/"&gt;Google Analytics&lt;/a&gt;可以更好的管理自己的站点，按顺序注册，得到&lt;code&gt;Tracking ID&lt;/code&gt;配置到&lt;code&gt;pelicanconf.py&lt;/code&gt;里面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;GOOGLE_ANALYTICS = &amp;#39;Tracking ID&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Google Webmasters&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.google.com/webmasters/"&gt;Google Webmasters&lt;/a&gt;是Google的站长工具，使用它的目的是让博客被Google更好的收录，比如手动让Googlebot抓取、提交Robots、更新Sitemap等功能，使用起来非常方便。要想使用Google Webmasters只要在&lt;a href="https://www.google.com/analytics/"&gt;Google Webmasters&lt;/a&gt;上注册即可。&lt;/p&gt;
&lt;h2&gt;URL配置&lt;/h2&gt;
&lt;p&gt;使用URL配置可以更好的设置博文的URL。打开&lt;code&gt;pelicanconf.py&lt;/code&gt;，按照如下修改或添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ARTICLE_URL = &amp;#39;posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/&amp;#39;
ARTICLE_SAVE_AS = &amp;#39;posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时的URL为&lt;code&gt;http://allotory.github.io/posts/2014/09/08/pelican-install/&lt;/code&gt;,而文件保存路径为&lt;code&gt;http://allotory.github.io/posts/2014/09/08/pelican-install/index.html&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;到目前为止博客基本功能已经搭建完成，部分功能还可以进一步完善，最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/1-screenshot.png" /&gt;&lt;/p&gt;</summary><category term="Python"></category><category term="Pelican"></category><category term="GitHub"></category><category term="Markdown"></category></entry></feed>