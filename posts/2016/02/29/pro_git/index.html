<!doctype html>
<html lang="en">
<head>
<title>Git基础笔记</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, maximum-scale=1">
<meta name="description" content="">
<meta name="author" content="Ellery">

<link rel="shortcut icon" href="http://allotory.github.io/images/favicon.ico">

<link href="http://allotory.github.io/theme/css/monokai_sublime.css" rel="stylesheet" type="text/css">
<link href="http://allotory.github.io/theme/css/bootstrap.css" rel="stylesheet" type="text/css">
<link href="http://allotory.github.io/theme/css/style.css" rel="stylesheet" type="text/css">
<link href="http://allotory.github.io/theme/css/font-awesome.css" rel="stylesheet" type="text/css">
<link href="http://allotory.github.io/theme/css/responsive.css" rel="stylesheet" type="text/css">
<link href="http://allotory.github.io/theme/css/animate.css" rel="stylesheet" type="text/css">

<!--[if IE]><style type="text/css">.pie {behavior:url(PIE.htc);}</style><![endif]-->

<script type="text/javascript" src="http://allotory.github.io/theme/js/jquery.1.8.3.min.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/bootstrap.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/jquery-scrolltofixed.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/jquery.easing.1.3.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/jquery.isotope.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/wow.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/classie.js"></script>
<script type="text/javascript" src="http://allotory.github.io/theme/js/highlight.pack.js"></script>
<script type="text/javascript">
$(document).ready(function() {
	$('pre').each(function(i, block) {
		hljs.highlightBlock(block);
	});
});
</script>

<!--[if lt IE 9]>
	<script src="http://allotory.github.io/js/respond-1.1.0.min.js"></script>
	<script src="http://allotory.github.io/js/html5shiv.js"></script>
	<script src="http://allotory.github.io/js/html5element.js"></script>
<![endif]-->

<link href="http://allotory.github.io/feeds/all.rss.xml" type="application/atom+xml" rel="alternate" title="Amazilia Full Atom Feed" />
<link href="http://allotory.github.io/feeds/git.rss.xml" type="application/atom+xml" rel="alternate" title="Amazilia Categories Atom Feed" />

	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-54438115-1', 'auto');
		ga('send', 'pageview');
	</script>
</head>
<body>

<nav class="main-nav-outer" id="test"><!--main-nav-start-->
	<div class="container">
		<ul class="main-nav">
			<li><a href="http://allotory.github.io/">Home</a></li>

					<li><a href="http://allotory.github.io/about-me.html">About</a></li>
					<li><a href="http://allotory.github.io/my-life.html">Life</a></li>

			<li class="small-logo"><i class="fa-tree"></i>

				<li><a href="feeds/all.rss.xml">Feed</a></li>
				<li><a href="#">Page2</a></li>
				<li><a href="#">Page3</a></li>
			
			
		</ul>
		<a class="res-nav_click" href="#"><i class="fa-bars"></i></a>
	</div>
</nav><!--main-nav-end-->

<section class="main-section" id="service"><!--main-section-start-->
	<div class="container">
		<div class="row">
			
<div class="col-lg-3 col-sm-3 col-md-3 col-xs-12 wow fadeInLeft delay-05s">
	<div class="service-list">
		<div class="service-list-col1">
			<i class="fa-paw"></i>
		</div>
		<div class="service-list-col2">
			<h3>Pages</h3>
			<p>
				<a href="http://allotory.github.io/">Home</a><br/>
						<a href="http://allotory.github.io/about-me.html">About</a><br/>
						<a href="http://allotory.github.io/my-life.html">Life</a><br/>

					<a href="feeds/all.rss.xml">Feed</a><br/>
					<a href="#">Page2</a><br/>
					<a href="#">Page3</a><br/>
			</p>
		</div>
	</div>
	
	<div class="service-list">
		<div class="service-list-col1">
			<i class="fa-pagelines"></i>
		</div>
		<div class="service-list-col2">
			<h3>Categories</h3>
			<p>
					<a href="http://allotory.github.io/git/index.html">Git</a><br/>
					<a href="http://allotory.github.io/ide/index.html">IDE</a><br/>
					<a href="http://allotory.github.io/java/index.html">Java</a><br/>
					<a href="http://allotory.github.io/javascript/index.html">Javascript</a><br/>
					<a href="http://allotory.github.io/python/index.html">Python</a><br/>
					<a href="http://allotory.github.io/server/index.html">Server</a><br/>
			</p>
		</div>
	</div>
	
	<div class="service-list">
		<div class="service-list-col1">
			<i class="fa-tags"></i>
		</div>
		<div class="service-list-col2">
			<h3>Tags</h3>
			<p>
					<a href="http://allotory.github.io/tag/css.html">CSS</a>
					<a href="http://allotory.github.io/tag/markdown.html">Markdown</a>
					<a href="http://allotory.github.io/tag/python.html">Python</a>
					<a href="http://allotory.github.io/tag/security.html">Security</a>
					<a href="http://allotory.github.io/tag/git.html">Git</a>
					<a href="http://allotory.github.io/tag/vim.html">Vim</a>
					<a href="http://allotory.github.io/tag/mysql.html">MySQL</a>
					<a href="http://allotory.github.io/tag/pelican.html">Pelican</a>
					<a href="http://allotory.github.io/tag/ide.html">IDE</a>
					<a href="http://allotory.github.io/tag/django.html">Django</a>
					<a href="http://allotory.github.io/tag/javascript.html">Javascript</a>
					<a href="http://allotory.github.io/tag/server.html">Server</a>
					<a href="http://allotory.github.io/tag/github.html">GitHub</a>
					<a href="http://allotory.github.io/tag/java.html">Java</a>
			</p>
		</div>
	</div>
	
	<div class="service-list">
		<div class="service-list-col1">
			<i class="fa-link"></i>
		</div>
		<div class="service-list-col2">
			<h3>Links</h3>
			<p>
					<a href="http://getpelican.com/">Pelican</a><br/>
					<a href="http://python.org/">Python.org</a><br/>
					<a href="http://jinja.pocoo.org/">Jinja2</a><br/>
					<a href="#">You can modify those links </a><br/>
			</p>
		</div>
	</div>
	
	<div class="service-list">
		<div class="service-list-col1">
			<i class="fa-facebook-square"></i>
		</div>
		<div class="service-list-col2">
			<h3>Social</h3>
			<p>
					<a href="feeds/all.rss.xml">RSS</a><br/>
					<a href="https://github.com/allotory">Github</a><br/>
					<a href="https://www.facebook.com/allotory">Facebook</a><br/>
					<a href="https://twitter.com/allotory">Twitter</a><br/>
			</p>
		</div>
	</div>
</div>
			<figure class="col-lg-9 col-sm-6  text-left wow fadeInUp delay-02s">
				<div class="post">                        
					<a href="http://allotory.github.io/posts/2016/02/29/pro_git/" rel="bookmark"
						title="Permalink to Git基础笔记"
						style="color:black; text-align:center">
						<h1>Git基础笔记</h1>
					</a>
					

					<span  title="2016-02-29T00:00:00+08:00">2016-02-29</span><br/>        
					
					<span class="posted-by">By 
						<a href="http://allotory.github.io/author/ellery.html">
							Ellery
						</a>
					</span>
   

					<div class="entry-content2">
						<ol>
<li>
<p>版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
</li>
<li>
<p>集中化的版本控制系统（Centralized Version Control Systems，简称CVCS ），诸如 CVS，Subversion 以及 Perforce 等，最显而易见的缺点是中央服务器的单点故障。</p>
</li>
<li>
<p>分布式版本控制系统（ Distributed Version Control System，简称DVCS ），诸如 Git，Mercurial，Bazaar 还有 Darcs 等。</p>
</li>
<li>
<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</p>
<p>已提交表示该文件已经被安全地保存在本地数据库中了；—— git commit</p>
<p>已修改表示修改了某个文件，但还没有提交保存；</p>
<p>已暂存表示把已修改的文件放在下次提交时要保存的清单中。—— git add</p>
</li>
<li>
<p>Git 管理项目时，文件流转的三个工作区域：Git 的本地数据目录，工作目录以及暂存区域。</p>
</li>
<li>
<p>每个项目都有一个 git 目录，它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
</li>
<li>
<p>基本的 Git 工作流程</p>
<p><img alt="screenshot" src="/images/11_local_operations.png" /></p>
<ul>
<li>
<p>在工作目录中修改某些文件。</p>
</li>
<li>
<p>对这些修改了的文件作快照，并保存到暂存区域。</p>
</li>
<li>
<p>提交更新，将保存在暂存区域的文件快照转储到git 目录中。</p>
</li>
</ul>
</li>
<li>
<p>git config（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li>
<p>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。</p>
</li>
<li>
<p>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用--global 选项，读写的就是这个文件。</p>
</li>
<li>
<p>当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</p>
</li>
</ul>
</li>
<li>
<p>配置个人的用户名称和电子邮件地址：</p>
<div class="highlight"><pre><span class="nv">$ </span>git config --global user.name <span class="s2">&quot;Ellery Zhang&quot;</span>
<span class="nv">$ </span>git config --global user.email al**ry@msn.com
</pre></div>


</li>
<li>
<p>默认使用的文本编辑器，Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。</p>
<div class="highlight"><pre><span class="nv">$ </span>git config --global core.editor emacs
</pre></div>


</li>
<li>
<p>检查已有的配置信息，可以使用 git config --list 命令</p>
<div class="highlight"><pre><span class="nv">$ </span>git config --list
core.symlinks<span class="o">=</span><span class="nb">false</span>
core.autocrlf<span class="o">=</span><span class="nb">true</span>
color.diff<span class="o">=</span>auto
color.status<span class="o">=</span>auto
color.branch<span class="o">=</span>auto
color.interactive<span class="o">=</span><span class="nb">true</span>
pack.packsizelimit<span class="o">=</span>2g
help.format<span class="o">=</span>html
http.sslcainfo<span class="o">=</span>/bin/curl-ca-bundle.crt
sendemail.smtpserver<span class="o">=</span>/bin/msmtp.exe
diff.astextplain.textconv<span class="o">=</span>astextplain
rebase.autosquash<span class="o">=</span><span class="nb">true</span>
gui.encoding<span class="o">=</span>utf-8
i18n.commitencoding<span class="o">=</span>GB2312
svn.pathnameencoding<span class="o">=</span>GB2312
user.name<span class="o">=</span>Ellery  Zhang
user.email<span class="o">=</span>al***ry@msn.com
core.autocrlf<span class="o">=</span><span class="nb">true</span>
core.excludesfile<span class="o">=</span>D:<span class="se">\D</span>ocuments<span class="se">\g</span>itignore_global.txt
i18n.commitencoding<span class="o">=</span>utf-8
</pre></div>


<p>可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可。</p>
<div class="highlight"><pre><span class="nv">$ </span>git config user.name
Ellery  Zhang
</pre></div>


</li>
<li>
<p>想了解 Git 的各式工具该怎么用，可以阅读它们的使用帮助，有三种方法：</p>
<div class="highlight"><pre><span class="nv">$ </span>git <span class="nb">help</span> &lt;verb&gt;
<span class="nv">$ </span>git &lt;verb&gt; --help
<span class="nv">$ </span>man git-&lt;verb&gt;
</pre></div>


<p>例如：学习 config 用法，会在浏览器中打开帮助页面。</p>
<div class="highlight"><pre><span class="nv">$ </span>git <span class="nb">help </span>config
Launching default browser to display HTML ...
</pre></div>


</li>
<li>
<p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<div class="highlight"><pre><span class="nv">$ </span>git init
</pre></div>


</li>
<li>
<p>如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。克隆仓库的命令格式为 git clone [url] 。</p>
<div class="highlight"><pre><span class="nv">$ </span>git clone git@github.com:allotory/mellisuga.git
</pre></div>


<p>如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令最后指定：</p>
<div class="highlight"><pre><span class="nv">$ </span>git clone git@github.com:allotory/mellisuga.git newname
</pre></div>


</li>
<li>
<p>Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s):// 或者 user@server:/path.git 表示的 SSH 传输协议。</p>
</li>
<li>
<p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。</p>
<p>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新（未修改），已修改或者已放入暂存区。</p>
<p>所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。</p>
<p><img alt="screenshot" src="/images/11_life_cycle.png" /></p>
</li>
<li>
<p>要确定哪些文件当前处于什么状态，可以用 git status 命令。</p>
<div class="highlight"><pre><span class="nv">$ </span>git status
</pre></div>


<p>新建一个 readme文件，再次查看状态</p>
<div class="highlight"><pre><span class="nv">$ </span>git status
On branch master
Initial commit
Untracked files:
  <span class="o">(</span>use <span class="s2">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed<span class="o">)</span>
        readme.txt
nothing added to commit but untracked files present <span class="o">(</span>use <span class="s2">&quot;git add&quot;</span> to track<span class="o">)</span>
</pre></div>


</li>
<li>
<p>使用命令 git add 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p>
<div class="highlight"><pre><span class="nv">$ </span>git add readme.txt
</pre></div>


<p>再次查看状态  </p>
<div class="highlight"><pre><span class="nv">$ </span>git status
On branch master
Initial commit
Changes to be committed:
  <span class="o">(</span>use <span class="s2">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage<span class="o">)</span>
        new file:   readme.txt
</pre></div>


</li>
<li>
<p>提交更新时请一定要确认还有什么修改过的或新建的文件还没有git add 过，否则提交的时候不会记录这些还没暂存起来的变化。</p>
<p>所以，每次提交前，先用git status 看下，是不是都已暂存，然后再运行提交命令git commit：</p>
<div class="highlight"><pre><span class="nv">$ </span>git commit -m <span class="s1">&#39;add readme&#39;</span>
<span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> a40e540<span class="o">]</span> add readme
 <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>
 create mode <span class="m">100644</span> readme.txt
</pre></div>


<p>-m 参数后跟提交说明。如果不使用 -m 参数，则会启动文本编辑器以便输入本次提交的说明。</p>
<p>可以看到，提交后它会告诉你，当前是在（master）分支提交的，本次提交的完整 SHA-1 校验和是（a40e540），以及在本次提交中，有（1）个文件修订过，（1）行添改和删改过。</p>
</li>
<li>
<p>暂存已修改文件，修改readme文件后查看状态</p>
<div class="highlight"><pre><span class="nv">$ </span>git status
On branch master
Changes not staged <span class="k">for</span> commit:
  <span class="o">(</span>use <span class="s2">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed<span class="o">)</span>
  <span class="o">(</span>use <span class="s2">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory<span class="o">)</span>
        modified:   readme.txt
no changes added to commit <span class="o">(</span>use <span class="s2">&quot;git add&quot;</span> and/or <span class="s2">&quot;git commit -a&quot;</span><span class="o">)</span>
</pre></div>


<p>文件 readme.txt 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 </p>
<p>要暂存这次更新，需要运行 git add 命令。</p>
<div class="highlight"><pre><span class="nv">$ </span>git add readme.txt
<span class="nv">$ </span>git status
On branch master
Changes to be committed:
  <span class="o">(</span>use <span class="s2">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage<span class="o">)</span>
        modified:   readme.txt
</pre></div>


<p>此时文件已暂存，下次提交时就会一并记录到仓库。 </p>
</li>
<li>
<p>git status 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status --short 命令，你将得到更为紧凑的格式输出。</p>
</li>
<li>
<p>我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p>
</li>
<li>
<p>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>
<p>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配。</p>
</li>
<li>
<p>匹配模式可以以（ / ）开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以（ / ）结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（ ! ）取反。</p>
</li>
</ul>
</li>
<li>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入</p>
<div class="highlight"><pre><span class="nv">$ </span>git diff
</pre></div>


<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。</p>
<p>git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。</p>
</li>
<li>
<p>若要查看已暂存的将要添加到下次提交的内容，可以用</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> diff --cached</span>
</pre></div>


<p>或（推荐使用）</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> diff --staged</span>
</pre></div>


</li>
<li>
<p>Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> rm</span>
</pre></div>


<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> rm -f</span>
</pre></div>


<p>如果想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留该文件在当前操作目录中。</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> rm  --cached</span>
</pre></div>


</li>
<li>
<p>Git 中对文件重命名</p>
<div class="highlight"><pre><span class="nv">$ </span>git mv file_from file_to
</pre></div>


<p>其实，运行 git mv 就相当于运行了下面三条命令：</p>
<div class="highlight"><pre><span class="nv">$ </span>mv README.md README
<span class="nv">$ </span>git rm README.md
<span class="nv">$ </span>git add README
</pre></div>


</li>
<li>
<p>查看提交历史</p>
<div class="highlight"><pre><span class="nv">$ </span>git log
</pre></div>


<p>默认时此命令会按提交时间倒序列出所有的更新，会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<div class="highlight"><pre>commit a40e54088aa857b2b46c0c9fe0a0f2455bea51a5
Author: Ellery &lt;allotory@msn.com&gt;
Date:   Mon Jan 4 16:40:47 2016 +0800
    add readme
</pre></div>


<p>git log 有很多参数，参数是 -p ，用来显示每次提交的内容差异。 -2 来表示仅显示最近两次提交</p>
<div class="highlight"><pre><span class="nv">$ </span>git log -p -2
</pre></div>


<p>想看到每次提交的简略的统计信息，你可以使用 --stat 参数</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --stat
</pre></div>


<p>--stat 参数在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。</p>
<p>--shortstat 只显示 --stat 中最后的参数修改添加移除统计。</p>
<p>另一个常用的参数是 --pretty 。 这个参数可以指定使用不同于默认格式的方式展示提交历史。</p>
<p>比如 oneline 将每个提交放在一行显示，查看的提交数很大时很有用，此时仅会显示sha-1和提交说明。</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>oneline
b413d95e070aa3dc4ad425644a4086f00c983ba7 add <span class="nb">test</span>
559eb5339da498e847eadb3d579bc267d0684627 insert readme
a40e54088aa857b2b46c0c9fe0a0f2455bea51a5 add readme
</pre></div>


<p>另外还有 short 格式:</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>short
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author: Ellery &lt;allotory@msn.com&gt;
    add <span class="nb">test</span>
</pre></div>


<p>full格式 :</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>full
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author: Ellery &lt;allotory@msn.com&gt;
Commit: Ellery &lt;allotory@msn.com&gt;
    add <span class="nb">test</span>
</pre></div>


<p>fuller格式 </p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>fuller
commit b413d95e070aa3dc4ad425644a4086f00c983ba7
Author:     Ellery &lt;allotory@msn.com&gt;
AuthorDate: Mon Jan <span class="m">4</span> 16:55:11 <span class="m">2016</span> +0800
Commit:     Ellery &lt;allotory@msn.com&gt;
CommitDate: Mon Jan <span class="m">4</span> 16:55:11 <span class="m">2016</span> +0800
    add <span class="nb">test</span>
</pre></div>


<p>format参数可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用。</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>format:<span class="s2">&quot;%h - %an, %ar : %s&quot;</span>
b413d95 - Ellery, <span class="m">6</span> days ago : add <span class="nb">test</span>
559eb53 - Ellery, <span class="m">6</span> days ago : insert readme
a40e540 - Ellery, <span class="m">6</span> days ago : add readme
</pre></div>


<p>当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些     ASCII字符串来形象地展示你的分支、合并历史</p>
<div class="highlight"><pre><span class="nv">$ </span>git log --pretty<span class="o">=</span>format:<span class="s2">&quot;%h %s&quot;</span> --graph
</pre></div>


</li>
<li>
<p>撤消操作</p>
<div class="highlight"><pre><span class="nv">$ </span>git commit --amend
</pre></div>


<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，所修改的只是提交信息。</p>
</li>
<li>
<p>取消已暂存文件，将以暂存的文件从暂存区移除</p>
<div class="highlight"><pre><span class="nv">$ </span>git reset HEAD test.md
</pre></div>


</li>
<li>
<p>撤消对文件的修改</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout -- test.md
</pre></div>


</li>
<li>
<p>远程仓库是指托管在因特网或其他网络中的项目的版本库。</p>
</li>
<li>
<p>查看已经配置的远程仓库服务器，可以使用 git remote 命令，如果你已经克隆了远程的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字</p>
<div class="highlight"><pre><span class="nv">$ </span>git remote
origin
</pre></div>


<p>指定选项 -v ，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<div class="highlight"><pre><span class="nv">$ </span>git remote -v
origin  git@github.com:allotory/mellisuga.git <span class="o">(</span>fetch<span class="o">)</span>
origin  git@github.com:allotory/mellisuga.git <span class="o">(</span>push<span class="o">)</span>
</pre></div>


</li>
<li>
<p>添加远程仓库，运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库</p>
<div class="highlight"><pre><span class="p">$</span><span class="nv">git</span><span class="x"> remote add me git@github.com:allotory/mellisuga.git</span>
</pre></div>


<p>在命令行中使用字符串 me 来代替整个 URL。</p>
<p>如果你想拉取远程仓库中有但你没有的信息，可以运行</p>
<div class="highlight"><pre><span class="x"> </span><span class="p">$</span><span class="nv">git</span><span class="x"> fetch me</span>
</pre></div>


<p>等价于</p>
<div class="highlight"><pre><span class="x"> </span><span class="p">$</span><span class="nv">git</span><span class="x"> fetch git@github.com:allotory/mellisuga.git</span>
</pre></div>


</li>
<li>
<p>从远程仓库中抓取与拉取</p>
<div class="highlight"><pre><span class="nv">$ </span>git fetch <span class="o">[</span>remote-name<span class="o">]</span>
</pre></div>


<p>例如</p>
<div class="highlight"><pre><span class="nv">$ </span>git fetch origin
</pre></div>


<p>因为 clone 命令克隆了某个仓库，命令会自动将其添加为远程仓库并默认以 'origin' 为简写。所以上述命令将会拥有那个远程仓库中所有分支的引用。</p>
<div class="highlight"><pre><span class="nv">$ </span>git fetch origin master
</pre></div>


<p>抓取回origin主机的master分支到本地。</p>
<p>git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。</p>
</li>
<li>
<p>如果有一个分支设置为跟踪一个远程分支， git pull 命令来自动的抓取然后合并远程分支到当前分支。</p>
<p>默认情况下， git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
</li>
<li>
<p>推送到远程仓库</p>
<div class="highlight"><pre>git push [remotename] [branch-name]
</pre></div>


<p>要将 master 分支推送到 origin 服务器时</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin master
</pre></div>


</li>
<li>
<p>查看某个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。会列出远程仓库的 URL 与跟踪分支的信息</p>
<div class="highlight"><pre><span class="nv">$ </span>git remote show origin
* remote origin
  Fetch URL: git@github.com:allotory/mellisuga.git
  Push  URL: git@github.com:allotory/mellisuga.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured <span class="k">for</span> <span class="s1">&#39;git pull&#39;</span>:
    master merges with remote master
  Local ref configured <span class="k">for</span> <span class="s1">&#39;git push&#39;</span>:
    master pushes to master <span class="o">(</span>up to date<span class="o">)</span>
</pre></div>


</li>
<li>
<p>要重命名引用的名字可以运行 git remote rename 去修改远程仓库的简写名</p>
<div class="highlight"><pre><span class="nv">$ </span>git remote rename me mellisuga
</pre></div>


<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 me/master 的现在会引用 mellisuga/master</p>
</li>
<li>
<p>要移除远程仓库</p>
<div class="highlight"><pre><span class="nv">$ </span>git remote rm mellisuga
</pre></div>


</li>
<li>
<p>Git 可以给历史中的某个提交打上标签，以示重要。 比较有代表性的是使用这个功能来标记发布结点（v1.0 等等）。</p>
</li>
<li>
<p>列出标签</p>
<div class="highlight"><pre><span class="nv">$ </span>git tag
</pre></div>


</li>
<li>
<p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
</li>
<li>
<p>附注标签</p>
<div class="highlight"><pre><span class="nv">$ </span>git tag -a v0.1 -m <span class="s1">&#39;my first version 0.1&#39;</span>
</pre></div>


<p>-m 选项指定了一条将会存储在标签中的信息。</p>
<p>使用 git show 命令可以看到标签信息与对应的提交信息</p>
<div class="highlight"><pre><span class="nv">$ </span>git show v0.1
tag v0.1
Tagger: Ellery &lt;allotory@msn.com&gt;
Date:   Sat Jan <span class="m">23</span> 21:35:49 <span class="m">2016</span> +0800
my first version v0.1
…
</pre></div>


<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<p>轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 -a 、 -s 或 -m 选项，只需要提供标签名字：</p>
<div class="highlight"><pre><span class="nv">$ </span>git tag v0.1
</pre></div>


<p>如果在标签上运行 git show ，你不会看到额外的标签信息。 命令只会显示出提交信息。</p>
<p>可以对过去的提交打标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）:</p>
<div class="highlight"><pre><span class="nv">$ </span>git tag -a v0.01 5593b
</pre></div>


<p>如不使用 -m 选项时，会默认调用 vim 编辑器编辑标签信息。</p>
</li>
<li>
<p>默认情况下， git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。- 你可以运行 git push origin [tagname]</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin v0.1
</pre></div>


<p>如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin --tags
</pre></div>


</li>
<li>
<p>创建新分支</p>
<p>创建新分支只是为你创建了一个个可以移动的新的指针。如，创建一个 iss53 分支， 你需要使用 git branch 命令</p>
<p><img alt="screenshot" src="/images/11_basic_branching_1.png" /></p>
<div class="highlight"><pre><span class="nv">$ </span>git branch iss53
</pre></div>


<p>这会在当前所在的提交对象上创建一个指针 iss53</p>
<p><img alt="screenshot" src="/images/11_basic_branching_2.png" /></p>
<p>Git 区分当前实在哪个分支上时，使用的是一个名为 HEAD 的特殊指针。指向当前所在的本地分支（可以将 HEAD 想象为当前分支的别名）。</p>
<p>此时HEAD指针仍然在 master 分支上。 因为 git branch 命令仅仅创建一个新分支，并不会自动切换到新分支中去。</p>
</li>
<li>
<p>切换到一个已存在的分支，你需要使用 git checkout 命令</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout iss53
</pre></div>


<p>这样 HEAD 就指向 iss53 分支了。</p>
</li>
<li>
<p>可以简单地使用 git log 命令查看分叉历史。它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<div class="highlight"><pre>git log --oneline --decorate --graph --all
</pre></div>


</li>
<li>
<p>想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout -b iss53
</pre></div>


<p>它是下面两条命令的简写</p>
<div class="highlight"><pre><span class="nv">$ </span>git branch iss53
<span class="nv">$ </span>git checkout iss53
</pre></div>


</li>
<li>
<p>分支合并，当 iss53 分支进行修改并提交后，可以将其与 master 分支合并，需要先切换到 master 分支，然后调用 git merge命令合并分支。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge iss53
</pre></div>


</li>
<li>
<p>当你试图合并两个分支时，如果顺着这个分分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
</li>
<li>
<p>删除分支</p>
<div class="highlight"><pre><span class="nv">$ </span>git branch -d iss53
</pre></div>


</li>
<li>
<p>你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。在合并它们的时候就会产生合并冲突，此时 Git 做了合并，但是没有主动地创建一个新的合并提交。</p>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态（unmerged）标识出来</p>
</li>
<li>
<p>分支管理</p>
<p>查看分支列表</p>
<div class="highlight"><pre><span class="nv">$ </span>git branch
</pre></div>


<p>如果需要查看每个分支的最后一次提交，可以运行</p>
<div class="highlight"><pre><span class="nv">$ </span>git branch -v
</pre></div>


<p>--merged 与 --no-merged 这两个选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</p>
<p>如果分支包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败，如果需要可以使用 -D参数强制删除。</p>
</li>
<li>
<p>远程引用（origin）是对远程仓库的引用（指针），包括分支、标签等，来显式地获得远程引用的完整列表：</p>
<div class="highlight"><pre>git ls-remote (remote-name)
</pre></div>


<p>或者</p>
<div class="highlight"><pre>git remote show (remote-name)
</pre></div>


</li>
<li>
<p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。它们以 (remote)/(branch) 形式命名。</p>
</li>
<li>
<p>远程跟踪分支，假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin ，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master 。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。</p>
<div class="highlight"><pre>            服务器（被命名） 本地
默认仓库名   origin          -
默认分支名   origin/master   master
</pre></div>


</li>
<li>
<p>本地分支 dev 推送到远程仓库</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin dev
</pre></div>


<p>如果在远程仓库希望改名字，可以使用</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin dev: newname
</pre></div>


</li>
<li>
<p>其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/dev ，指向服务器的 dev 分支的引用。</p>
<p>特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。即，这种情况下，不会有一个新的 dev 分支 - 只有一个不可以修改的 origin/dev 指针。</p>
<p>可以运行 git merge origin/dev 将这些工作合并到当前所在的分支。</p>
<p>如果想要在自己的本地 dev 分支上工作，可以将其建立在远程跟踪分支之上。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout -b dev origin/dev
</pre></div>


</li>
<li>
<p>从一个远程跟踪分支检出的一个本地分支会自动创建一个叫做跟踪分支，跟踪分支是与远程分支有直接关系的本地分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。</p>
<p>可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout --track origin/serverfix
</pre></div>


<p>将本地分支与远程分支设置为不同名字，本地分支 sf 会自动从 origin/serverfix 拉取。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout -b sf origin/serverfix
</pre></div>


<p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。</p>
<div class="highlight"><pre><span class="nv">$ </span>git branch -vv
</pre></div>


</li>
<li>
<p>删除远程分支</p>
<div class="highlight"><pre><span class="nv">$ </span>git push origin --delete serverfix
</pre></div>


</li>
<li>
<p>在 Git 中整合来自不同分支的修改主要有两种方法： merge 以及 rebase 。</p>
<p>开发任务分叉到两个不同分支，又各自提交了更新。</p>
<p><img alt="screenshot" src="/images/12_basic_rebase_1.png" /></p>
<p>整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<p><img alt="screenshot" src="/images/12_basic_rebase_2.png" /></p>
<p>还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。 在 Git 中，这种操作就叫做 变基。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout experiment
<span class="nv">$ </span>git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged <span class="nb">command</span>
</pre></div>


<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>
<p><img alt="screenshot" src="/images/12_basic_rebase_3.png" /></p>
<p>现在回到 master 分支，进行一次快进合并。</p>
<div class="highlight"><pre><span class="nv">$ </span>git checkout master
<span class="nv">$ </span>git merge experiment
</pre></div>


<p><img alt="screenshot" src="/images/12_basic_rebase_4.png" /></p>
<p>两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。</p>
<p>使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的  experiment ）变基到目标分支（即 master）上。这样做能省去你先切换到 experiment 分支，再对其执行变基命令的多个步骤。</p>
</li>
<li>
<p>变基也并非完美无缺，要用它得遵守一条准则：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>
</li>
</ol>
					</div>

					<div class="post-tags">
							<i class="fa-tags"></i>
							<a href="http://allotory.github.io/tag/git.html">Git</a>
					</div>   
				</div>  

				<div class="comments" style="color:black;">
					<h3>Comments</h3>
					<div id="disqus_thread"></div>
					<script type="text/javascript">
						var disqus_identifier = "posts/2016/02/29/pro_git/";
						(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = 'http://amazilia.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
						})();
					</script>
				</div>
			</figure>
		</div>
	</div>
</section><!--main-section-end-->

<footer class="footer">
	<div class="container">
		<div class="footer-logo"><i class="fa-tree"></i></div>
		<span class="copyright">Copyright © 2016 By <a href="http://allotory.github.io">Ellery</a>.</span>
	</div>
</footer> 

<script type="text/javascript">
	$(document).ready(function(e) {
		$('#test').scrollToFixed();
		$('.res-nav_click').click(function(){
			$('.main-nav').slideToggle();
			return false 
		});
	});
</script>

<script>
	wow = new WOW({
		animateClass: 'animated',
		offset: 100
	});
	wow.init();
	// document.getElementById('').onclick = function() {
	// 	var section = document.createElement('section');
	// 	section.className = 'wow fadeInDown';
	// 	this.parentNode.insertBefore(section, this);
	// };
</script>
<script type="text/javascript">
	var disqus_shortname = 'amazilia';
	(function () {
		var s = document.createElement('script'); s.async = true;
		s.type = 'text/javascript';
		s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
		(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
	}());
</script>
</body>
</html>